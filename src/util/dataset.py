import pyrealsense2 as rs
import numpy as np
import cv2
import argparse
import os


class ImageSequence:
    def __init__(self, path):
        self.iter = load_dataset(path)

    def set(self, key, value):
        pass

    def read(self):
        try:
            rgb, _ = next(self.iter)
            return True, rgb
        except StopIteration:
            return False, None

    def release(self):
        pass


def create_dataset(width, height, path='data'):
    pipeline = rs.pipeline()
    config = rs.config()
    config.enable_stream(rs.stream.depth, width, height, rs.format.z16, 30)
    config.enable_stream(rs.stream.color, width, height, rs.format.bgr8, 30)

    color_path = path+'/rgb'
    depth_path = path+'/depth'

    if not os.path.exists(color_path):
        os.makedirs(color_path)
    if not os.path.exists(depth_path):
        os.makedirs(depth_path)

    profile = pipeline.start(config)

    # Getting the depth sensor's depth scale (see rs-align example for explanation)
    depth_sensor = profile.get_device().first_depth_sensor()
    depth_scale = depth_sensor.get_depth_scale()

    print("Depth Scale is: ", depth_scale)
    file_names = open(path+'/names.txt', "w+")

    try:
        count = 1
        while True:
            frames = pipeline.wait_for_frames()
            depth_frame = frames.get_depth_frame()
            color_frame = frames.get_color_frame()
            if not depth_frame or not color_frame:
                continue

            # convert images to numpy arrays
            depth_image = np.asanyarray(depth_frame.get_data())
            color_image = np.asanyarray(color_frame.get_data())
            # depth_colormap = cv2.applyColorMap(cv2.convertScaleAbs(depth_image, alpha=0.03), cv2.COLORMAP_JET)

            # depth = depth_image[320,240].astype(float)

            file_names.write(f'{count}.png\n')
            cv2.imwrite(f"{color_path}/{count}.png", color_image)
            cv2.imwrite(f"{depth_path}/{count}.png", depth_image)
            cv2.imshow('Stream', color_image)

            if cv2.waitKey(1) == ord("q"):
                break
            count += 1
    finally:
        pipeline.stop()


def load_dataset(path):
    color_path = path+'/rgb'
    depth_path = path+'/depth'
    file_names = open(path+'/names.txt', 'r')
    names = file_names.readlines()
    for name in names:
        rgb_img = cv2.imread(color_path+f'/{name[:-1]}')
        depth_img = cv2.imread(depth_path+f'/{name[:-1]}', -1)
        yield name[:-5], rgb_img, depth_img*0.0010000000474974513

def load_estimation_dataset(path, estimator):
    color_path = path+'/rgb'
    depth_path = path+'/depth'
    estimation_path = path+f'/{estimator}'
    file_names = open(path+'/names.txt', 'r')
    names = file_names.readlines()
    for name in names:
        rgb_img = cv2.imread(color_path+f'/{name[:-1]}')
        depth_img = cv2.imread(depth_path+f'/{name[:-1]}', -1)
        depth_estimation = np.load(estimation_path+f'/{name[:-5]}.npy')
        yield name[:-5], rgb_img, depth_img*0.0010000000474974513, depth_estimation


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='tool to create or load datasets generated by intel realsense d455')

    parser.add_argument('--width', type=int, required=False, default=640,
                        help='camera capture mode: width')
    parser.add_argument('--height', type=int, required=False, default=360,
                        help='camera capture mode: height')
    parser.add_argument('--path', type=str, required=False, default='data',
                        help='where the data should be stored')

    args = parser.parse_args()

    create_dataset(args.width, args.height, args.path)
    for rgb_image, depth_image in load_dataset(args.path):
        depth_colormap = cv2.applyColorMap(cv2.convertScaleAbs(
            depth_image/0.0010000000474974513, alpha=0.03), cv2.COLORMAP_JET)
        cv2.imshow('Stream', depth_colormap)
        if cv2.waitKey(1) == ord("q"):
            break
